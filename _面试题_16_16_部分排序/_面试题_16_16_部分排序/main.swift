//
//  main.swift
//  _面试题_16_16_部分排序
//
//  Created by 曾维俊 on 2020/2/29.
//  Copyright © 2020 Nius. All rights reserved.
//

import Foundation

/**
 给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。

 示例：
 输入： [1,2,4,7,10,11,7,12,6,7,16,18,19]
 输出： [3,9]
 
 提示：
 0 <= len(array) <= 1000000

 来源：力扣（LeetCode）
 链接：https://leetcode-cn.com/problems/sub-sort-lcci
 */

class Solution {
    func subSort(_ array: [Int]) -> [Int] {
        // 说明中表示范围 0 <= len(array) <= 1000000，数组长度有可能是0，需要判断边界
        if array.count == 0 {
            return [-1, -1]
        }
        
        // 本题思路其实就是寻找逆序对，第一个逆序对位置和最后一个逆序对位置，只要将处于这两个逆序对之间的元素排序后，整个数组就排好序
        // 例如：[2, 3, 1, 4]  只要将3，1排序即可，一次位置为[1, 2]
        // 例如：[4, 5, 4, 3, 2, 6, 7, 2, 3] 肉眼可以看出，首元素4和尾元素3就是一个逆序对，因此需要全排序 [0, 8]
        // 例如：[1, 5, 4, 3, 2, 6, 7, 2, 8] 肉眼可以看出，第二个元素5和倒数第二个元素2是逆序对，排序范围为[1, 7]
        // 关键在于确定逆序对的第一个元素和最后一个元素位置，可以使用两次遍历方式
        // 例子[1, 5, 4, 3, 2, 6, 7, 2, 8]中
        //      要找到最后一个逆序对2的位置，只需从头到尾找到最后一个逆序对位置2
        //      要找到第一个逆序对5的位置，只需从尾往前找到第一个逆序对的位置5
        /** 总体思路
          1.从头到尾遍历，找打逆序对最后一个元素位置
          2.从后往前遍历，找到逆序对第一个元素位置
        注意：确定逆序对需要使用最大或者最小元素确定位置
         
         使用一个指针记录最大，另一个指针记录逆序对位置
         */
        
        
        /**
         边界条件
         0 1 1 1 2 1 1 2 3  --> 0 1 1 1 (2 1 1) 2 3 // 不要将后边2放进去，后边那个2加入没有意义，只会增加时间复杂度
         
         */
        
        // 从前向后扫描
        var max = array[0] // 默认第0最大，从1号位置开始扫描
        var last = -1
        for cur in 1..<array.count {
            let tmp = array[cur]
            if tmp >= max { // 将相等写上，else中不记录为逆序对
                max = tmp
            } else { // tmp < max 存在逆序对 （相等的时候不要记录成为逆序对，课减小排序范围）
                last = cur // 记录位置
            }
        }
        
        // 从后向前扫描
        var min = array[array.count - 1] // 默认第n-1最大，从n-2号位置开始扫描
        var first = -1
        for cur in (0...(array.count - 2)).reversed() {
            let tmp = array[cur]
            if tmp <= min {  // 将相等写上，else中不记录为逆序对
                min = tmp
            } else { // tmp > min 存在逆序对 （相等的时候不要记录成为逆序对，课减小排序范围）
                first = cur // 记录位置
            }
        }
        
        return [first, last]
    }
    
    func subSort1(_ array: [Int]) -> [Int] {
        // 说明中表示范围 0 <= len(array) <= 1000000，数组长度有可能是0，需要判断边界
        if array.count == 0 {
            return [-1, -1]
        }
        
        // 本题思路其实就是寻找逆序对，第一个逆序对位置和最后一个逆序对位置，只要将处于这两个逆序对之间的元素排序后，整个数组就排好序
        // 例如：[2, 3, 1, 4]  只要将3，1排序即可，一次位置为[1, 2]
        // 例如：[4, 5, 4, 3, 2, 6, 7, 2, 3] 肉眼可以看出，首元素4和尾元素3就是一个逆序对，因此需要全排序 [0, 8]
        // 例如：[1, 5, 4, 3, 2, 6, 7, 2, 8] 肉眼可以看出，第二个元素5和倒数第二个元素2是逆序对，排序范围为[1, 7]
        // 关键在于确定逆序对的第一个元素和最后一个元素位置，可以使用两次遍历方式
        // 例子[1, 5, 4, 3, 2, 6, 7, 2, 8]中
        //      要找到最后一个逆序对2的位置，只需从头到尾找到最后一个逆序对位置2
        //      要找到第一个逆序对5的位置，只需从尾往前找到第一个逆序对的位置5
        /** 总体思路
          1.从头到尾遍历，找打逆序对最后一个元素位置
          2.从后往前遍历，找到逆序对第一个元素位置
        注意：确定逆序对需要使用最大或者最小元素确定位置
         
         使用一个指针记录最大，另一个指针记录逆序对位置
         */
        
        
        /**
         边界条件
         0 1 1 1 2 1 1 2 3  --> 0 1 1 1 (2 1 1) 2 3
         // 从前向后扫描：不要将后边2放进去，后边那个2加入没有意义，只会增加时间复杂度
         // 从后向前扫描：同理
         */
        
        // 使用i从前向后扫描，使用j从后往前扫描
        var max = array[0] // 默认第0最大，从1号位置开始扫描
        var min = array[array.count - 1] // 默认第n-1最大，从n-2号位置开始扫描
        var last = -1
        var first = -1
        let count = array.count
        for i in 1..<count {
            let tmp1 = array[i]
            if tmp1 >= max { // 将相等写上，else中不记录为逆序对
                max = tmp1
            } else { // tmp < max 存在逆序对 （相等的时候不要记录成为逆序对，课减小排序范围）
                last = i // 记录位置
            }

            // 整合逆序到同一个for循环
            let j = count - i - 1
            let tmp2 = array[j]
            if tmp2 <= min {  // 将相等写上，else中不记录为逆序对
                min = tmp2
            } else { // tmp > min 存在逆序对 （相等的时候不要记录成为逆序对，课减小排序范围）
                first = j // 记录位置
            }
        }
        return [first, last]
    }
    
    // 优化，如果正向扫描后没有发现逆序对，说明排好序，直接退出
    func subSort2(_ array: [Int]) -> [Int] {
        // 说明中表示范围 0 <= len(array) <= 1000000，数组长度有可能是0，需要判断边界
        if array.count == 0 {
            return [-1, -1]
        }
        
        // 本题思路其实就是寻找逆序对，第一个逆序对位置和最后一个逆序对位置，只要将处于这两个逆序对之间的元素排序后，整个数组就排好序
        // 例如：[2, 3, 1, 4]  只要将3，1排序即可，一次位置为[1, 2]
        // 例如：[4, 5, 4, 3, 2, 6, 7, 2, 3] 肉眼可以看出，首元素4和尾元素3就是一个逆序对，因此需要全排序 [0, 8]
        // 例如：[1, 5, 4, 3, 2, 6, 7, 2, 8] 肉眼可以看出，第二个元素5和倒数第二个元素2是逆序对，排序范围为[1, 7]
        // 关键在于确定逆序对的第一个元素和最后一个元素位置，可以使用两次遍历方式
        // 例子[1, 5, 4, 3, 2, 6, 7, 2, 8]中
        //      要找到最后一个逆序对2的位置，只需从头到尾找到最后一个逆序对位置2
        //      要找到第一个逆序对5的位置，只需从尾往前找到第一个逆序对的位置5
        /** 总体思路
          1.从头到尾遍历，找打逆序对最后一个元素位置
          2.从后往前遍历，找到逆序对第一个元素位置
        注意：确定逆序对需要使用最大或者最小元素确定位置
         
         使用一个指针记录最大，另一个指针记录逆序对位置
         */
        
        
        /**
         边界条件
         0 1 1 1 2 1 1 2 3  --> 0 1 1 1 (2 1 1) 2 3 // 不要将后边2放进去，后边那个2加入没有意义，只会增加时间复杂度
         
         */
        
        // 从前向后扫描
        var max = array[0] // 默认第0最大，从1号位置开始扫描
        var last = -1
        for cur in 1..<array.count {
            let tmp = array[cur]
            if tmp >= max { // 将相等写上，else中不记录为逆序对
                max = tmp
            } else { // tmp < max 存在逆序对 （相等的时候不要记录成为逆序对，课减小排序范围）
                last = cur // 记录位置
            }
        }
        
        // 优化，如果正向扫描后没有发现逆序对，说明排好序，直接退出
        if last < 0 {
            return [-1, -1]
        }
        
        
        // 从后向前扫描
        var min = array[array.count - 1] // 默认第n-1最大，从n-2号位置开始扫描
        var first = -1
        for cur in (0...(array.count - 2)).reversed() {
            let tmp = array[cur]
            if tmp <= min {  // 将相等写上，else中不记录为逆序对
                min = tmp
            } else { // tmp > min 存在逆序对 （相等的时候不要记录成为逆序对，课减小排序范围）
                first = cur // 记录位置
            }
        }
        
        return [first, last]
    }
}

print(Solution().subSort([1, 5, 4, 3, 2, 6, 7, 2, 8]))
print(Solution().subSort([4, 5, 4, 3, 2, 6, 7, 2, 3]))

print(Solution().subSort1([1, 5, 4, 3, 2, 6, 7, 2, 8]))
print(Solution().subSort1([4, 5, 4, 3, 2, 6, 7, 2, 3]))
